<!-- WARNING! Run in incognito (or localhost:8081) since WalletConnect can't properly sync IndexedDB state over multiple tabs -->

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <title>WalletConnect Tezos Example Wallet</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/water.css@2/out/water.css" />
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/sign-client@2.18.0/dist/index.umd.js"></script>
  </head>

  <body>
    WalletConnect Tezos Example Wallet
    <br /><br />
    <div id="status">Status: Initializing...</div>
    <br /><br />

    <!-- Pair / Disconnect / Reset buttons -->
    <button id="paste">Pair with URI</button>
    <button id="disconnect">Disconnect Session</button>
    <button id="reset">Reset and Refresh</button>
    <button id="update">Update Session</button>

    <br /><br />
    <div id="sessions">
      <strong>Active Sessions:</strong>
      <div id="session-list"></div>
    </div>

    <script>
      let signClient = null
      const projectId = '97f804b46f0db632c52af0556586a5f3' // ← your WalletConnect Project ID

      // Mock Tezos wallet data
      let walletData = {
        address: 'tz1VSUr8wwNhLAzempoch5d6hLRiTh8Cjcjb',
        publicKey: 'edpkvGfYw3LyB1UcCahKQk4rF2tvbMUk8GFiTuMjL75uGXrpvKXhjn',
        privateKey: 'edsktesttesttesttesttesttesttesttesttesttesttestte',
        network: {
          type: 'ghostnet',
          name: 'Tezos Ghostnet',
          rpcUrl: 'https://ghostnet.api.tez.ie'
        }
      }

      const setStatus = (status) => {
        document.getElementById('status').innerText = status ? 'Status: ' + status : 'Status: Ready'
      }

      const updateSessionList = () => {
        if (!signClient) return
        const sessions = signClient.session.getAll()
        const sessionList = document.getElementById('session-list')

        if (sessions.length === 0) {
          sessionList.innerHTML = '<div>No active sessions</div>'
        } else {
          sessionList.innerHTML = sessions
            .map(
              (session) =>
                `<div>Session: ${session.topic.substring(0, 8)}... | Peer: ${session.peer.metadata.name}</div>`
            )
            .join('')
        }
      }

      // Initialize WalletConnect SignClient
      const initializeWalletConnect = async () => {
        try {
          setStatus('Initializing WalletConnect...')
          const SignClientClass =
            window.SignClient ||
            window.WalletConnect?.SignClient ||
            window.WalletConnectSignClient?.SignClient ||
            window['@walletconnect/sign-client']?.SignClient

          if (!SignClientClass) {
            throw new Error(
              'SignClient not found. Available: ' +
                Object.keys(window)
                  .filter((key) => key.toLowerCase().includes('wallet'))
                  .join(', ')
            )
          }

          signClient = await SignClientClass.init({
            projectId: projectId,
            metadata: {
              name: 'Example Tezos Wallet',
              description: 'WalletConnect Tezos Example Wallet',
              url: window.location.origin,
              icons: [
                'https://assets.website-files.com/61748e1c1c733a4ca33f1dd5/618d5e5faa4beaefd41b7fc8_tezos_symbol_blue.svg'
              ]
            }
          })

          setStatus('Ready')
          signClient.on('session_proposal', onSessionProposal)
          signClient.on('session_request', onSessionRequest)
          signClient.on('session_delete', onSessionDelete)
          signClient.on('session_expire', onSessionExpire)
          updateSessionList()
        } catch (error) {
          console.error('Failed to initialize WalletConnect:', error)
          setStatus('Failed to initialize')
        }
      }

      // 1) Handle incoming session proposals and auto‐approve
      const onSessionProposal = async (event) => {
        console.log('Session proposal received:', event)
        setStatus('Session proposal received...')
        const { id, params } = event
        const { requiredNamespaces, optionalNamespaces, relays } = params

        try {
          // Build the namespaces object so the dApp knows what methods/events/chains we support
          const namespaces = {}
          for (const [key, namespace] of Object.entries(requiredNamespaces)) {
            if (key === 'tezos') {
              namespaces[key] = {
                accounts: [`tezos:ghostnet:${walletData.address}`],
                methods: namespace.methods || ['tezos_getAccounts', 'tezos_send', 'tezos_sign'],
                events: namespace.events || [],
                chains: namespace.chains || ['tezos:ghostnet']
              }
            } else {
              // Fallback for any other namespace
              namespaces[key] = {
                accounts: [`${key}:ghostnet:${walletData.address}`],
                methods: namespace.methods,
                events: namespace.events,
                chains: namespace.chains || [`${key}:ghostnet`]
              }
            }
          }
          // If there are optionalNamespaces, mirror them here
          if (optionalNamespaces) {
            for (const [key, namespace] of Object.entries(optionalNamespaces)) {
              if (!namespaces[key]) {
                if (key === 'tezos') {
                  namespaces[key] = {
                    accounts: [`tezos:ghostnet:${walletData.address}`],
                    methods: namespace.methods || ['tezos_getAccounts', 'tezos_send', 'tezos_sign'],
                    events: namespace.events || [],
                    chains: namespace.chains || ['tezos:ghostnet']
                  }
                } else {
                  namespaces[key] = {
                    accounts: [`${key}:ghostnet:${walletData.address}`],
                    methods: namespace.methods,
                    events: namespace.events,
                    chains: namespace.chains || [`${key}:ghostnet`]
                  }
                }
              }
            }
          }

          // Approve the session with our “namespaces”
          const session = await signClient.approve({
            id,
            namespaces
          })
          setStatus('Session approved')
          updateSessionList()
        } catch (error) {
          console.error('Failed to approve session:', error)
          setStatus('Failed to approve session')
          await signClient.reject({
            id,
            reason: { code: 5000, message: 'Failed to approve session' }
          })
        }
      }

      // 2) Handle all incoming method calls (e.g. tezos_getAccounts, tezos_send, tezos_sign, etc.)
      const onSessionRequest = async (event) => {
        console.log('Session request received:', event)
        setStatus('Handling request...')

        const { topic, params, id } = event
        const { request } = params

        try {
          let result
          switch (request.method) {
            case 'tezos_getAccounts':
              result = [
                {
                  algo: 'ed25519',
                  address: walletData.address,
                  pubkey: walletData.publicKey
                }
              ]
              break
            case 'tezos_send':
              const operations = request.params?.operations || request.params
              result = {
                operationHash: `op${Math.random().toString(36).substr(2, 9)}${Date.now().toString(36)}`,
                operations: operations.map((op, i) => ({
                  ...op,
                  counter: (12345 + i).toString(),
                  fee: op.fee || '1420',
                  gas_limit: op.gas_limit || '10600',
                  storage_limit: op.storage_limit || '257'
                }))
              }
              break
            case 'tezos_sign':
              const signPayload = request.params?.payload || request.params
              result = {
                signature: `edsig${Math.random().toString(36).substr(2, 20)}${Date.now().toString(36)}`,
                signedPayload: signPayload,
                publicKey: walletData.publicKey
              }
              break
            case 'tezos_requestPermissions':
              result = {
                address: walletData.address,
                publicKey: walletData.publicKey,
                network: walletData.network,
                scopes: ['tezos_getAccounts', 'tezos_send', 'tezos_sign']
              }
              break
            default:
              throw new Error(`Unsupported Tezos method: ${request.method}`)
          }

          // Always respond back to the dApp
          await signClient.respond({
            topic,
            response: {
              id,
              result,
              jsonrpc: '2.0'
            }
          })
          setStatus('Request handled')
        } catch (error) {
          console.error('Failed to handle request:', error)
          await signClient.respond({
            topic,
            response: {
              id,
              error: {
                code: 5000,
                message: error.message || 'Request failed'
              },
              jsonrpc: '2.0'
            }
          })
          setStatus('Request failed')
        }
      }

      // 3) Clean up when the session is deleted or expired
      const onSessionDelete = (event) => {
        console.log('Session deleted:', event)
        setStatus('Session disconnected')
        updateSessionList()
      }
      const onSessionExpire = (event) => {
        console.log('Session expired:', event)
        setStatus('Session expired')
        updateSessionList()
      }

      // Pair with URI
      document.getElementById('paste').addEventListener('click', async () => {
        if (!signClient) return

        try {
          uri = await navigator.clipboard.readText()
        } catch {
          alert('Please paste a WalletConnect URI in the input field')
          return
        }

        if (!uri.startsWith('wc:')) {
          alert('Invalid WalletConnect URI. It should start with "wc:"')
          return
        }
        try {
          setStatus('Pairing...')
          await signClient.pair({ uri })
          setStatus('Ready')
          document.getElementById('uri-input').value = ''
        } catch (err) {
          console.error('Pairing failed:', err)
          setStatus('Pairing failed')
          alert('Pairing failed: ' + err.message)
        }
      })

      // Disconnect all sessions
      document.getElementById('disconnect').addEventListener('click', async () => {
        if (!signClient) return
        const sessions = signClient.session.getAll()
        if (sessions.length === 0) {
          alert('No active sessions to disconnect')
          return
        }
        try {
          setStatus('Disconnecting sessions...')
          for (const session of sessions) {
            await signClient.disconnect({
              topic: session.topic,
              reason: { code: 6000, message: 'User disconnected' }
            })
          }
          setStatus('Disconnected')
          updateSessionList()
        } catch (error) {
          console.error('Disconnect failed:', error)
          setStatus('Disconnect failed')
        }
      })

      // Reset wallet (clear storage + disconnect)
      document.getElementById('reset').addEventListener('click', async () => {
        try {
          if (signClient) {
            const sessions = signClient.session.getAll()
            for (const session of sessions) {
              await signClient.disconnect({
                topic: session.topic,
                reason: { code: 6000, message: 'Wallet reset' }
              })
            }
          }
          localStorage.clear()
          sessionStorage.clear()
          window.location.reload()
        } catch (error) {
          console.error('Reset failed:', error)
          window.location.reload()
        }
      })

      document.getElementById('update').addEventListener('click', async () => {
        if (!signClient) {
          alert('SignClient not initialized yet')
          return
        }

        const newAddress = 'tz1TwNWHfczra9ubmB9qbqw49EJN3fVcwsVo'
        const newPbk = 'edpku28rWpLN6CksuPZMwE3Ew2AdVeRyVoddJhkUEqksrPybgvEWRn'

        // 2) Find the single active session (or let user pick one if you have multiple)
        const sessions = signClient.session.getAll()
        if (sessions.length === 0) {
          alert('No active session to update')
          return
        }

        // In this example, we just pick the first session.
        // If you have multiple sessions, you might show a list or allow selecting by topic.
        const session = sessions[0]
        const topic = session.topic

        try {
          setStatus('Updating session...')
          // 3) Clone the existing namespaces so we can modify them
          const namespaces = { ...session.namespaces }

          // 4) Update the Tezos account entry (index 0) to use the new address
          //    Format is “tezos:ghostnet:<address>”
          //    (if you also need to update publicKey in index 1, do so here)
          const oldEntry = namespaces.tezos.accounts[0].split(':')
          // oldEntry is [ "tezos", "ghostnet", "<oldAddress>" ]
          oldEntry[2] = newAddress
          namespaces.tezos.accounts[0] = oldEntry.join(':')

          // 5) (Optional) If this wallet’s namespaces.tezos.accounts[1] was storing a public key,
          //    you would update that index too. For example:
          //    if (namespaces.tezos.accounts.length > 1) {
          //      let pkEntry = namespaces.tezos.accounts[1].split(':');
          //      pkEntry[2] = YOUR_NEW_PUBLIC_KEY_HERE;
          //      namespaces.tezos.accounts[1] = pkEntry.join(':');
          //    }

          console.log('Calling signClient.update with namespaces:', namespaces)

          // 6) Call update(...) and wait for dApp to acknowledge
          const { acknowledged } = await signClient.update({
            topic,
            namespaces
          })
          await acknowledged() // wait until dApp acknowledges the update

          // 7) Update our local mock walletData.address as well
          walletData.address = newAddress
          walletData.publicKey = newPbk

          setStatus('Session updated!')
          updateSessionList()
          setStatus(`Session successfully updated to ${newAddress}`)
        } catch (err) {
          console.error('Failed to update session:', err)
          setStatus('Update failed')
          alert('Failed to update session: ' + err.message)
        }
      })

      // Initialize when page loads
      window.addEventListener('load', () => {
        setTimeout(() => {
          if (!projectId || projectId === 'YOUR_PROJECT_ID') {
            setStatus('Please set your WalletConnect Project ID')
            alert(
              'Please replace YOUR_PROJECT_ID with your actual WalletConnect Project ID from https://cloud.walletconnect.com/'
            )
            return
          }
          initializeWalletConnect()
        }, 500)
      })
    </script>
  </body>
</html>
